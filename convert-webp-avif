#!/usr/bin/env bash
set -euo pipefail

WEBP_QUALITY="${WEBP_QUALITY:-85}"
AVIF_QUALITY="${AVIF_QUALITY:-}"
DEFAULT_AVIF_QUALITY="${DEFAULT_AVIF_QUALITY:-37}"

ROOT_DIR="/work"

EXCLUDE_PATHS=()
if [[ -d "${ROOT_DIR%/}/lost+found" ]]; then
  EXCLUDE_PATHS+=("${ROOT_DIR%/}/lost+found")
fi

if ! command -v cwebp >/dev/null 2>&1; then
  echo "cwebp not found on PATH" >&2
  exit 1
fi

if ! command -v avifenc >/dev/null 2>&1; then
  echo "avifenc not found on PATH" >&2
  exit 1
fi

log() {
  printf '[asset-convert] %s\n' "$*" >&2
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

needs_rebuild() {
  local source="$1"
  local target="$2"
  [[ ! -f "$target" || "$source" -nt "$target" ]]
}

normalize_path() {
  local target="$1"
  if [[ "$target" == /* ]]; then
    printf '%s\n' "$target"
  else
    printf '%s\n' "${ROOT_DIR%/}/$target"
  fi
}

find_images() {
  local dir="$1"
  local -a find_cmd=(find "$dir")
  for exclude in "${EXCLUDE_PATHS[@]}"; do
    find_cmd+=(-path "$exclude" -prune -o)
  done
  find_cmd+=(-type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' \) -print0)
  "${find_cmd[@]}" 2>/dev/null
}

gather_from_dir() {
  local dir="$1"
  if [[ ! -d "$dir" ]]; then
    log "Skipping missing directory $dir"
    return
  fi
  find_images "$dir"
}

gather_from_file() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    log "Skipping missing file $file"
    return
  fi
  case "${file,,}" in
    *.jpg|*.jpeg|*.png|*.gif)
      printf '%s\0' "$file"
      ;;
    *)
      log "Skipping unsupported file $file"
      ;;
  esac
}

collect_all() {
  find_images "$ROOT_DIR"
}

quantizer_to_quality() {
  local min_q="$1"
  local max_q="$2"
  awk -v min="$min_q" -v max="$max_q" 'BEGIN {
    avg=(min+max)/2.0
    if (avg < 0) {
      avg = 0
    }
    if (avg > 63) {
      avg = 63
    }
    q=100 - (avg * 100.0 / 63.0)
    if (q < 0) {
      q = 0
    }
    if (q > 100) {
      q = 100
    }
    printf("%d", (q >= 0) ? int(q + 0.5) : 0)
  }'
}

determine_avif_quality() {
  if [[ -n "$AVIF_QUALITY" ]]; then
    printf '%s\n' "$AVIF_QUALITY"
    return
  fi

  if [[ -n ${AVIF_MIN+set} || -n ${AVIF_MAX+set} ]]; then
    local min_value="${AVIF_MIN:-30}"
    local max_value="${AVIF_MAX:-50}"
    if [[ "$min_value" =~ ^[0-9]+$ && "$max_value" =~ ^[0-9]+$ ]]; then
      local quality
      quality=$(quantizer_to_quality "$min_value" "$max_value")
      log "AVIF_MIN/AVIF_MAX are deprecated; using AVIF_QUALITY=$quality (from min=$min_value, max=$max_value)"
      printf '%s\n' "$quality"
      return
    else
      log "AVIF_MIN/AVIF_MAX must be numeric; falling back to default quality"
    fi
  fi

  printf '%s\n' "$DEFAULT_AVIF_QUALITY"
}

is_animated_gif() {
  command_exists gifsicle || return 1
  local frames
  frames=$(gifsicle --info "$1" 2>/dev/null | awk '/image #/ {count++} END {print count+0}')
  [[ "${frames:-0}" -gt 1 ]]
}

AVIF_ENCODING_QUALITY=$(determine_avif_quality)
readonly AVIF_ENCODING_QUALITY
AVIF_ALPHA_QUALITY="${AVIF_ALPHA_QUALITY:-$AVIF_ENCODING_QUALITY}"
readonly AVIF_ALPHA_QUALITY

mapfile -d '' -t targets < <(
  if [[ "$#" -eq 0 ]]; then
    collect_all | sort -z
  else
    for arg in "$@"; do
      abs=$(normalize_path "$arg")
      if [[ -d "$abs" ]]; then
        gather_from_dir "$abs"
      else
        gather_from_file "$abs"
      fi
    done | sort -z
  fi
)

if [[ "${#targets[@]}" -eq 0 ]]; then
  log "No images found to convert"
  exit 0
fi

convert_file() {
  local src="$1"
  local rel
  rel="${src#$ROOT_DIR/}"
  local dir
  dir="$(dirname "$rel")"
  local base
  base="$(basename "$rel")"
  local name="${base%.*}"
  local extension="${base##*.}"
  local lower_ext="${extension,,}"
  local animated_gif=false
  if [[ "$lower_ext" == "gif" ]] && is_animated_gif "$src"; then
    animated_gif=true
  fi
  local subdir=""
  if [[ "$dir" != "." ]]; then
    subdir="$dir/"
  fi

  local webp="${ROOT_DIR%/}/${subdir}${name}.webp"
  local avif="${ROOT_DIR%/}/${subdir}${name}.avif"

  local pretty_dir="${dir#./}"
  if [[ -z "$pretty_dir" || "$pretty_dir" == "." ]]; then
    pretty_dir="."
  fi

  if needs_rebuild "$src" "$webp"; then
    if [[ "$lower_ext" == "gif" && "$animated_gif" == true ]]; then
      if command_exists gif2webp; then
        log "Generating ${pretty_dir}/${name}.webp (animated GIF)"
        gif2webp -quiet -mixed -q "$WEBP_QUALITY" "$src" -o "$webp"
      else
        log "Generating ${pretty_dir}/${name}.webp"
        cwebp -quiet -q "$WEBP_QUALITY" "$src" -o "$webp"
      fi
    else
      log "Generating ${pretty_dir}/${name}.webp"
      cwebp -quiet -q "$WEBP_QUALITY" "$src" -o "$webp"
    fi
  else
    log "Skipping up-to-date $rel -> ${name}.webp"
  fi

  if needs_rebuild "$src" "$avif"; then
    log "Generating ${pretty_dir}/${name}.avif"
    avifenc -q "$AVIF_ENCODING_QUALITY" --alpha-quality "$AVIF_ALPHA_QUALITY" -j 0 --speed 6 "$src" "$avif"
  else
    log "Skipping up-to-date $rel -> ${name}.avif"
  fi
}

for target in "${targets[@]}"; do
  convert_file "$target"
done
