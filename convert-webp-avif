#!/usr/bin/env bash
set -euo pipefail

DEFAULT_WEBP_QUALITY="${WEBP_QUALITY:-85}"
readonly DEFAULT_WEBP_QUALITY
AVIF_QUALITY="${AVIF_QUALITY:-}"
DEFAULT_AVIF_QUALITY="${DEFAULT_AVIF_QUALITY:-37}"
readonly DEFAULT_AVIF_QUALITY

ROOT_DIR="/work"

EXCLUDE_PATHS=()
if [[ -d "${ROOT_DIR%/}/lost+found" ]]; then
  EXCLUDE_PATHS+=("${ROOT_DIR%/}/lost+found")
fi

if ! command -v cwebp >/dev/null 2>&1; then
  echo "cwebp not found on PATH" >&2
  exit 1
fi

if ! command -v avifenc >/dev/null 2>&1; then
  echo "avifenc not found on PATH" >&2
  exit 1
fi

detect_avif_alpha_flag() {
  local help_output
  help_output="$(avifenc --help 2>&1 || true)"

  if grep -q -- '--qalpha' <<<"$help_output"; then
    printf '%s\n' '--qalpha'
  elif grep -q -- '--alpha-quality' <<<"$help_output"; then
    printf '%s\n' '--alpha-quality'
  else
    printf '%s\n' '--qalpha'
  fi
}

log() {
  printf '[asset-convert] %s\n' "$*" >&2
}

usage() {
  cat <<'EOF'
Usage: convert-webp-avif [--profile "regex=<pattern>;webp=<q>;avif=<q>[;avif-alpha=<q>]"] [path ...]

When no paths are provided the converter scans the entire /work tree.

Multiple --profile flags may be supplied; the first matching regex applies.
Unspecified qualities in a profile fall back to the defaults/environment values.
EOF
}

trim_whitespace() {
  local value="$1"
  value="${value#${value%%[![:space:]]*}}"
  value="${value%${value##*[![:space:]]}}"
  printf '%s' "$value"
}

is_integer() {
  [[ "$1" =~ ^[0-9]+$ ]]
}

declare -a PROFILE_PATTERNS=()
declare -a PROFILE_WEBP_QUALITIES=()
declare -a PROFILE_AVIF_QUALITIES=()
declare -a PROFILE_AVIF_ALPHA_QUALITIES=()

parse_profile_definition() {
  local definition="$1"
  local regex=""
  local webp=""
  local avif=""
  local avif_alpha=""
  IFS=';' read -r -a parts <<<"$definition"
  local part
  for part in "${parts[@]}"; do
    part=$(trim_whitespace "$part")
    if [[ -z "$part" ]]; then
      continue
    fi
    case "$part" in
      regex=*)
        regex="${part#regex=}"
        ;;
      webp=*)
        webp="${part#webp=}"
        if [[ -n "$webp" ]]; then
          if ! is_integer "$webp"; then
            log "Invalid webp quality '$webp' in profile '$definition'"
            exit 1
          fi
        fi
        ;;
      avif=*)
        avif="${part#avif=}"
        if [[ -n "$avif" ]]; then
          if ! is_integer "$avif"; then
            log "Invalid avif quality '$avif' in profile '$definition'"
            exit 1
          fi
        fi
        ;;
      avif-alpha=*|avif_alpha=*)
        avif_alpha="${part#*=}"
        if [[ -n "$avif_alpha" ]]; then
          if ! is_integer "$avif_alpha"; then
            log "Invalid avif-alpha quality '$avif_alpha' in profile '$definition'"
            exit 1
          fi
        fi
        ;;
      *)
        log "Unrecognized profile segment '$part'"
        exit 1
        ;;
    esac
  done

  if [[ -z "$regex" ]]; then
    log "Profile '$definition' is missing regex=<pattern>"
    exit 1
  fi

  PROFILE_PATTERNS+=("$regex")
  PROFILE_WEBP_QUALITIES+=("$webp")
  PROFILE_AVIF_QUALITIES+=("$avif")
  PROFILE_AVIF_ALPHA_QUALITIES+=("$avif_alpha")
}

declare -a PROFILE_ARGUMENTS=()
declare -a POSITIONAL_ARGUMENTS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --profile)
      if [[ $# -lt 2 ]]; then
        log "--profile requires an argument"
        usage
        exit 1
      fi
      PROFILE_ARGUMENTS+=("$2")
      shift 2
      ;;
    --profile=*)
      PROFILE_ARGUMENTS+=("${1#--profile=}")
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    --)
      shift
      while [[ $# -gt 0 ]]; do
        POSITIONAL_ARGUMENTS+=("$1")
        shift
      done
      break
      ;;
    *)
      POSITIONAL_ARGUMENTS+=("$1")
      shift
      ;;
  esac
done

for profile in "${PROFILE_ARGUMENTS[@]}"; do
  parse_profile_definition "$profile"
done

set -- "${POSITIONAL_ARGUMENTS[@]}"

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

needs_rebuild() {
  local source="$1"
  local target="$2"
  [[ ! -f "$target" || "$source" -nt "$target" ]]
}

normalize_path() {
  local target="$1"
  if [[ "$target" == /* ]]; then
    printf '%s\n' "$target"
  else
    printf '%s\n' "${ROOT_DIR%/}/$target"
  fi
}

find_images() {
  local dir="$1"
  local -a find_cmd=(find "$dir")
  for exclude in "${EXCLUDE_PATHS[@]}"; do
    find_cmd+=(-path "$exclude" -prune -o)
  done
  find_cmd+=(-type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' \) -print0)
  "${find_cmd[@]}" 2>/dev/null
}

gather_from_dir() {
  local dir="$1"
  if [[ ! -d "$dir" ]]; then
    log "Skipping missing directory $dir"
    return
  fi
  find_images "$dir"
}

gather_from_file() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    log "Skipping missing file $file"
    return
  fi
  case "${file,,}" in
    *.jpg|*.jpeg|*.png|*.gif)
      printf '%s\0' "$file"
      ;;
    *)
      log "Skipping unsupported file $file"
      ;;
  esac
}

collect_all() {
  find_images "$ROOT_DIR"
}

quantizer_to_quality() {
  local min_q="$1"
  local max_q="$2"
  awk -v min="$min_q" -v max="$max_q" 'BEGIN {
    avg=(min+max)/2.0
    if (avg < 0) {
      avg = 0
    }
    if (avg > 63) {
      avg = 63
    }
    q=100 - (avg * 100.0 / 63.0)
    if (q < 0) {
      q = 0
    }
    if (q > 100) {
      q = 100
    }
    printf("%d", (q >= 0) ? int(q + 0.5) : 0)
  }'
}

determine_avif_quality() {
  if [[ -n "$AVIF_QUALITY" ]]; then
    printf '%s\n' "$AVIF_QUALITY"
    return
  fi

  if [[ -n ${AVIF_MIN+set} || -n ${AVIF_MAX+set} ]]; then
    local min_value="${AVIF_MIN:-30}"
    local max_value="${AVIF_MAX:-50}"
    if [[ "$min_value" =~ ^[0-9]+$ && "$max_value" =~ ^[0-9]+$ ]]; then
      local quality
      quality=$(quantizer_to_quality "$min_value" "$max_value")
      log "AVIF_MIN/AVIF_MAX are deprecated; using AVIF_QUALITY=$quality (from min=$min_value, max=$max_value)"
      printf '%s\n' "$quality"
      return
    else
      log "AVIF_MIN/AVIF_MAX must be numeric; falling back to default quality"
    fi
  fi

  printf '%s\n' "$DEFAULT_AVIF_QUALITY"
}

is_animated_gif() {
  command_exists gifsicle || return 1
  local frames
  frames=$(gifsicle --info "$1" 2>/dev/null | awk '/image #/ {count++} END {print count+0}')
  [[ "${frames:-0}" -gt 1 ]]
}

DEFAULT_AVIF_ENCODING_QUALITY=$(determine_avif_quality)
readonly DEFAULT_AVIF_ENCODING_QUALITY
DEFAULT_AVIF_ALPHA_QUALITY="${AVIF_ALPHA_QUALITY:-$DEFAULT_AVIF_ENCODING_QUALITY}"
readonly DEFAULT_AVIF_ALPHA_QUALITY
AVIF_ALPHA_FLAG=$(detect_avif_alpha_flag)
readonly AVIF_ALPHA_FLAG

declare SELECTED_WEBP_QUALITY=""
declare SELECTED_AVIF_QUALITY=""
declare SELECTED_AVIF_ALPHA_QUALITY=""

select_profile_for_path() {
  local path="$1"
  SELECTED_WEBP_QUALITY="$DEFAULT_WEBP_QUALITY"
  SELECTED_AVIF_QUALITY="$DEFAULT_AVIF_ENCODING_QUALITY"
  SELECTED_AVIF_ALPHA_QUALITY="$DEFAULT_AVIF_ALPHA_QUALITY"

  local idx
  for idx in "${!PROFILE_PATTERNS[@]}"; do
    if [[ "$path" =~ ${PROFILE_PATTERNS[$idx]} ]]; then
      local candidate
      candidate="${PROFILE_WEBP_QUALITIES[$idx]}"
      if [[ -n "$candidate" ]]; then
        SELECTED_WEBP_QUALITY="$candidate"
      fi
      candidate="${PROFILE_AVIF_QUALITIES[$idx]}"
      if [[ -n "$candidate" ]]; then
        SELECTED_AVIF_QUALITY="$candidate"
      fi
      candidate="${PROFILE_AVIF_ALPHA_QUALITIES[$idx]}"
      if [[ -n "$candidate" ]]; then
        SELECTED_AVIF_ALPHA_QUALITY="$candidate"
      fi
      break
    fi
  done
}

mapfile -d '' -t targets < <(
  if [[ "$#" -eq 0 ]]; then
    collect_all | sort -z
  else
    for arg in "$@"; do
      abs=$(normalize_path "$arg")
      if [[ -d "$abs" ]]; then
        gather_from_dir "$abs"
      else
        gather_from_file "$abs"
      fi
    done | sort -z
  fi
)

if [[ "${#targets[@]}" -eq 0 ]]; then
  log "No images found to convert"
  exit 0
fi

convert_file() {
  local src="$1"
  local rel
  rel="${src#$ROOT_DIR/}"
  local dir
  dir="$(dirname "$rel")"
  local base
  base="$(basename "$rel")"
  local name="${base%.*}"
  local extension="${base##*.}"
  local lower_ext="${extension,,}"
  local animated_gif=false
  local skip_avif=false
  if [[ "$lower_ext" == "gif" ]]; then
    if is_animated_gif "$src"; then
      animated_gif=true
    fi
    skip_avif=true
  fi
  local subdir=""
  if [[ "$dir" != "." ]]; then
    subdir="$dir/"
  fi

  local webp="${ROOT_DIR%/}/${subdir}${name}.webp"
  local avif="${ROOT_DIR%/}/${subdir}${name}.avif"

  local pretty_dir="${dir#./}"
  if [[ -z "$pretty_dir" || "$pretty_dir" == "." ]]; then
    pretty_dir="."
  fi

  select_profile_for_path "$rel"
  local webp_quality="$SELECTED_WEBP_QUALITY"
  local avif_quality="$SELECTED_AVIF_QUALITY"
  local avif_alpha_quality="$SELECTED_AVIF_ALPHA_QUALITY"

  if needs_rebuild "$src" "$webp"; then
    if [[ "$lower_ext" == "gif" && "$animated_gif" == true ]]; then
      if command_exists gif2webp; then
        log "Generating ${pretty_dir}/${name}.webp (animated GIF)"
        if ! gif2webp -quiet -mixed -q "$webp_quality" "$src" -o "$webp"; then
          log "Failed to convert $rel to WebP via gif2webp; skipping"
          rm -f "$webp"
          return 0
        fi
      else
        log "Generating ${pretty_dir}/${name}.webp"
        if ! cwebp -quiet -q "$webp_quality" "$src" -o "$webp"; then
          log "Failed to convert $rel to WebP via cwebp; skipping"
          rm -f "$webp"
          return 0
        fi
      fi
    else
      log "Generating ${pretty_dir}/${name}.webp"
      if ! cwebp -quiet -q "$webp_quality" "$src" -o "$webp"; then
        log "Failed to convert $rel to WebP via cwebp; skipping"
        rm -f "$webp"
        return 0
      fi
    fi
  else
    log "Skipping up-to-date $rel -> ${name}.webp"
  fi

  if [[ "$skip_avif" == true ]]; then
    log "Skipping ${pretty_dir}/${name}.avif (GIF input not supported)"
  elif needs_rebuild "$src" "$avif"; then
    log "Generating ${pretty_dir}/${name}.avif"
    if ! avifenc -q "$avif_quality" "$AVIF_ALPHA_FLAG" "$avif_alpha_quality" -j 0 --speed 6 "$src" "$avif"; then
      log "Failed to convert $rel to AVIF; skipping"
      rm -f "$avif"
      return 0
    fi
  else
    log "Skipping up-to-date $rel -> ${name}.avif"
  fi
}

for target in "${targets[@]}"; do
  convert_file "$target"
done
